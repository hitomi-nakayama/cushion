# ======== Environment Variables ========

# Get the name of the shell we're in right now.
CUSH_SHELL="$(ps -cp "$$" -o command='')"

case "${CUSH_SHELL}" in
  zsh) CUSH_SCRIPT="$0" ;;
  bash) CUSH_SCRIPT="${BASH_SOURCE[0]}" ;;
esac
CUSH_DIR="$(realpath "$(dirname "$CUSH_SCRIPT")")"


# set our VISUAL variable in order of perefence
export VISUAL="$(which nvim || which vim || which nano)"

if which nvim >/dev/null; then
    USING_NVIM='true'
fi

export EDITOR="${VISUAL}"

export TERM_CMD="$(which kitty)"

# Check if we're in a remote session
if pstree -s -p $$ | grep -c '\-sshd(' >/dev/null; then
  CUSH_REMOTE='true'
fi


# ======== Helper Functions ========

function error() {
  echo "$*" >&2
}


# ======== Shell Configuration ========

# ---- Hotkeys ----
# Home and End Keys
case "${CUSH_SHELL}" in
  zsh)
    bindkey '^[[H' beginning-of-line
    bindkey '^[[F' end-of-line
    ;;
  bash)
    bind '\e[[H':beginning-of-line
    bind '\e[[F':end-of-line
    ;;
esac

#######################################
# Create the path part of the shell prompt.
# Truncates the path components to shorten long paths.
# Globals:
#   HOME
# Arguments:
#   -r<n> set the redundancy level (5% by default)
#   Files/directories to open
#######################################
function cushion_prompt_path() {
  echo "${PWD}" | awk -v HOME="${HOME}" -f "${CUSH_DIR}/prompt_path.awk"
}

function cush_git_prompt() {
  local current_branch
  local status_short
  local status_symbols
  local commits_behind
  local commits_ahead

  status_short="$(git status -s 2>/dev/null)"

  if (( $? != 0 )); then
    return 1  # not inside of git repo
  fi

  printf '{'

  current_branch="$(git branch --show-current)"
  printf "${current_branch}"

  echo -n "${status_short}" | awk -f "${CUSH_DIR}/git_prompt_status.awk"

  commits_behind="$(git rev-list --right-only --count HEAD...@{upstream} 2>/dev/null||echo '0')"
  if (( commits_behind != 0 )); then
    printf "⇣${commits_behind}"
  fi

  commits_ahead="$(git rev-list --left-only --count HEAD...@{upstream} 2>/dev/null ||echo '0')"
  if (( commits_ahead != 0 )); then
    printf "⇡${commits_ahead}"
  fi

  printf '}\n'

}

#######################################
# Set the shell prompt
# Globals:
#   CUSH_SHELL
#   PS1
# Arguments:
#   -r<n> set the redundancy level (5% by default)
#   Files/directories to open
#######################################
function cush_set_ps1() {
  local path_part
  local remote_part
  local shell_symbol

  case "${CUSH_SHELL}" in
    zsh)
      setopt PROMPT_SUBST
      ;;
    bash)
      shopt -s promptvars
      ;;
  esac


  if [[ "${CUSH_REMOTE}" == 'true' ]]; then
    case "${CUSH_SHELL}" in
      zsh) remote_part='%n@%M:' ;;
      bash) remote_part='\u@\H:' ;;
    esac
  else
    remote_part=''
  fi

  case "${CUSH_SHELL}" in
    zsh) shell_symbol='%#' ;;
    bash) shell_symbol='\$' ;;
  esac

  PS1="${remote_part}"'$(cushion_prompt_path)$(cush_git_prompt)'"${shell_symbol} "
}
cush_set_ps1


# ---- History ----
# Enble history
case "${CUSH_SHELL}" in
  zsh)
    setopt HIST_EXPIRE_DUPS_FIRST
    setopt SHARE_HISTORY
    SAVEHIST=1000
    HISTSIZE=$(( SAVEHIST + 100 ))
    HISTFILE=~/.zsh_history
    ;;
  bash)
    ;;
esac


# disable software flow control
# (make Ctrl+S not pause the terminal)
stty -ixon

case "${CUSH_SHELL}" in
  zsh)
    bindkey '^R' history-incremental-pattern-search-backward
    bindkey '^S' history-incremental-pattern-search-forward
    ;;
  bash)
    ;;
esac


# ======== Directory Navigation ========

alias dv="dirs -v"

if which eza &> /dev/null; then
    alias l='eza --icons'
else
    alias l='ls --color=auto'
fi

if which eza &> /dev/null; then
    alias ll='eza --oneline --icons --long --group --time-style=long-iso'
else
    alias ll='ls -l -h --time-style="+%Y-%m-%d %H:%M" --color=auto'
fi

# ======== File System Manipulation ========

#######################################
# Create a directory and `cd` into it.
# Arguments:
#   Directories to create
#   The last provided directory will be `cd`'d into.
#######################################
function mkcd() {
  mkdir -p "$@" && cd "${@:$#}"
}

# ---- Symbolic Links ----
# move a relative symbolic link
function cplnrs() {
    for f in "${@:1:-1}"; do
        ln -rs "$(readlink -f "${f}")" "${@[-1]}"
    done
}

# move a relative symbolic link
function mvlnrs() {
    cplnrs "${@:1}" && rm "${@:1:-1}"
}


#######################################
# Create a par2 file
# Globals:
#   OPTIND
# Arguments:
#   -r<n> set the redundancy level (5% by default)
#   Files/directories to open
#######################################
function p2() {
  local dir_name
  local redundancy

  redundancy=5

  OPTIND=1  # Reset in case getopts has been used previously in the shell
  while getopts 'r:' flag; do
    case "${flag}" in
      r) redundancy="${OPTARG}" ;;
      *) error "Unexpected option ${flag}" ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  if [[ "${1:-}" == '--' ]]; then
    shift
  fi

  for f in "$@"; do
    if [[ -d "${f}" ]]; then
      dir_name="$(basename -- "${f}")"
      par2create "-r${redundancy}" -R "${dir_name}.par2" "${f}"
    else
      par2create "-r${redundancy}" "${f}"
    fi
  done
}

# Compress a file into tar.xz. This results in better compression than using
# the ordinary tar utility.
function txz() {
    tar -cv "$1" | xz -9e > "$(basename "$1").tar.xz"
}

alias uidmt="sudo mount -o uid=$(id -u),gid=$(id -g)"


# ======== Launching Programs ========

# display images in kitty terminal
alias icat="kitty +kitten icat"

#######################################
# Open a file with its default program
# Arguments:
#   file to open
#######################################
function o() {
  xdg-open "$1" &
  disown
}

# open a new terminal at the current directory
function s() {
  "${TERM_CMD}" "$(pwd)" </dev/null &>/dev/null &
  disown
}

#######################################
# Open an editor with a list of files to open
# Globals:
#   USING_NVIM
#   VISUAL
# Arguments:
#   Files to open
#######################################
function v() {
  local flags
  declare -a flags

  if [[ "${USING_NVIM}" == 'true' ]]; then
    # open files in tabs.
    flags+=('-p')
  fi

  "${VISUAL}" "${flags[@]}" "$@"
}

# ======== git ========

alias g='git'
alias gc='git commit'
alias gcam='git commit -am'
alias gcb='git checkout -b'
alias gco='git checkout'
alias gd='git diff'
alias gp='git push'
alias gst='git status'

# ======== Networking ========

# Alias ssh so that kitty can send the proper terminfo.
if [[ "${TERM}" == 'xterm-kitty' ]]; then
  alias ssh='kitty +kitten ssh'
fi

#######################################
# Create a new SSH Agent and add in the credentials in ~/.ssh
# Arguments:
#   None
#######################################
function agt() {
  eval "$(ssh-agent -s)"

  # using find because nullglobs are difficult to make combatible with both
  # zsh and bash
  find ~/.ssh -maxdepth 1 -name '*_rsa' -o -name '*_ed25519' \
    | xargs -o -I '{}' -- ssh-add '{}'
}


# ======== Package Management ========

# gentoo package management
function esync() {
  local timestamp
  local sync_time
  local now_time

  timestamp="$(cat $(portageq get_repo_path / gentoo)/metadata/timestamp.chk)"
  sync_time="$(date -d "${timestamp}" '+%s')"
  now_time="$(date '+%s')"

  if (( now_time - sync_time < 86400 )); then
    echo "You last synced less than 24 hours ago on ${timestamp}."
  else
    # if it's been 2 or more days, then first get a snapshot.
    if (( now_time - sync_time > 172800 )); then
        sudo emerge-webrsync
    fi
    sudo emerge --sync
  fi
}

alias eupdate="sudo emerge --ask --quiet --update --deep --newuse @world"
alias epurge="sudo emerge --ask --depclean && sudo eclean --deep distfiles && sudo eclean --deep packages"
